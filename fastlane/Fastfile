# fastlane/Fastfile

# -----------------------------------------------------------------------------
# BENVENUTO NEL TUO WORKFLOW AUTOMATIZZATO!
#
# Questo file definisce tutte le operazioni automatizzate per il tuo progetto.
# Per eseguirle, apri il terminale nella cartella principale del progetto e
# lancia i comandi descritti nella sezione "Come Usare".
# -----------------------------------------------------------------------------

default_platform(:ios)

# =============================================================================
# ‚öôÔ∏è PREREQUISITI E CONFIGURAZIONE
#
# 1. Assicurati di aver installato Fastlane: `sudo gem install fastlane`
# 2. Modifica le 3 variabili qui sotto con i dati del tuo progetto.
# 3. Per le release su GitHub, crea un Personal Access Token qui:
#    https://github.com/settings/tokens (con permesso "repo")
#    e impostalo nel tuo ambiente con:
#    `export FASTLANE_GITHUB_API_TOKEN="tuo_token_qui"`
#    (Aggiungi questa riga al tuo file .zshrc o .bash_profile per non doverlo
#    fare ogni volta).
# =============================================================================

# --- VARIABILI DA PERSONALIZZARE ---
PROJECT_NAME = "ProwlarriOS"
SCHEME_NAME = "ProwlarriOS"
REPO_NAME = "leonardosolari/ProwlarriOS"

# Definiamo i percorsi corretti una sola volta
XCODEPROJ_PATH = "#{PROJECT_NAME}.xcodeproj"
XCWORKSPACE_PATH = "#{XCODEPROJ_PATH}/project.xcworkspace"
# -----------------------------------

platform :ios do
  
  # ===========================================================================
  # üöÄ COME USARE QUESTO FILE
  #
  # 1. Per compilare e lanciare l'app sul simulatore:
  #    `fastlane run_sim`
  #
  # 2. Per creare una nuova release (minor, commit, tag, build IPA e upload):
  #    `fastlane release`
  #
  # 3. Per creare una release di tipo "patch" o "major":
  #    `fastlane release bump_type:patch`
  #    `fastlane release bump_type:major`
  # ===========================================================================

  desc "Compila e lancia l'app sul simulatore di default"
  lane :run_sim do
    
    # -------------------------------------------------------------------------
    # PASSO 1: Compila l'app per il simulatore usando 'gym'.
    # Non creiamo un .ipa, ma solo il file .app nella DerivedData.
    # -------------------------------------------------------------------------
    UI.message "üì¶ Compilando l'app per il simulatore..."
    gym(
      workspace: XCWORKSPACE_PATH,
      scheme: SCHEME_NAME,
      sdk: "iphonesimulator", # Specifica che la build √® per il simulatore
      destination: "platform=iOS Simulator,name=iPhone 16 Pro", # Specifica il simulatore
      derived_data_path: "./derived_data", # Specifichiamo dove salvare la build
      skip_package_ipa: true # Non vogliamo un .ipa, solo il file .app
    )
    
    # -------------------------------------------------------------------------
    # PASSO 2: Installa l'app sul simulatore.
    # L'azione 'install_on_simulator' √® deprecata. Usiamo 'xcrun simctl'.
    # Dobbiamo trovare il percorso del file .app appena creato.
    # -------------------------------------------------------------------------
    UI.message "üì≤ Installando l'app sul simulatore..."
    
    # Costruiamo il percorso del file .app all'interno della DerivedData
    app_path = "./derived_data/Build/Products/Debug-iphonesimulator/#{PROJECT_NAME}.app"
    
    # Eseguiamo il comando di installazione
    sh "xcrun simctl install booted '#{app_path}'"

    # -------------------------------------------------------------------------
    # PASSO 3: Lancia l'app.
    # Per lanciare l'app, abbiamo bisogno del suo Bundle Identifier.
    # Lo leggiamo direttamente dal file di progetto.
    # -------------------------------------------------------------------------
    UI.message "üöÄ Lanciando l'app..."
    
    # Ottiene il bundle identifier dal file di progetto
    bundle_id = get_info_plist_value(
      path: "#{XCODEPROJ_PATH}/../#{PROJECT_NAME}/Info.plist", # Percorso standard per Info.plist generato
      key: "CFBundleIdentifier",
      xcodeproj: XCODEPROJ_PATH
    )

    # Lancia l'app usando il suo identifier
    sh "xcrun simctl launch booted '#{bundle_id}'"

    UI.success "‚úÖ App compilata, installata e lanciata con successo!"
  end



  desc "Crea una nuova release completa: versione, commit, tag, build e upload su GitHub"
  lane :release do |options|
    ensure_git_status_clean
    UI.confirm("Sei sicuro di voler creare una nuova release? Questo modificher√† la versione, creer√† un commit e un tag.")

    # Determina il tipo di incremento di versione (default: minor)
    bump_type = options[:bump_type] || "minor"
    UI.message "üìà Incremento versione di tipo: #{bump_type}"

    # 1. Gestione Automatica della Versione
    increment_version_number(bump_type: bump_type)
    
    new_version_number = get_version_number

    # 2. Crea un commit e un tag Git
    commit_version_bump(
      message: "chore(release): Versione #{new_version_number}",
      xcodeproj: XCODEPROJ_PATH # <-- MODIFICA QUI
    )
    add_git_tag(tag: "v#{new_version_number}")

    # 3. Crea il file IPA non firmato
    UI.message "üì¶ Creazione del file IPA non firmato..."
    ipa_path = _build_unsigned_ipa(version: new_version_number)
    
    # 4. Crea la release su GitHub
    UI.message "‚òÅÔ∏è Creazione della release su GitHub e upload dell'IPA..."
    set_github_release(
      repository_name: REPO_NAME,
      name: "Release v#{new_version_number}",
      tag_name: "v#{new_version_number}",
      description: "Release v#{new_version_number}. Allego l'IPA per l'installazione.",
      upload_assets: [ipa_path]
    )

    # 5. Fai il push di commit e tag sul repository remoto
    push_to_git_remote

    UI.success "üéâ Release v#{new_version_number} completata e pubblicata con successo su GitHub!"
  end


  # ---------------------------------------------------------------------------
  # --- LANE PRIVATE (Funzioni di supporto, non chiamare direttamente) ---
  # ---------------------------------------------------------------------------
  
  private_lane :_build_unsigned_ipa do |options|
    version = options[:version]
    output_dir = "./Builds"
    final_ipa_name = "#{PROJECT_NAME}-v#{version}.ipa"

    # 1. Archivia il progetto senza tentare di firmarlo o pacchettizzarlo
    archive_path = gym(
      workspace: XCWORKSPACE_PATH, # <-- MODIFICA QUI
      scheme: SCHEME_NAME,
      skip_package_ipa: true,
      archive_path: "#{output_dir}/#{PROJECT_NAME}.xcarchive",
      xcargs: "CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO"
    )

    # 2. Estrai il file .app e crea l'IPA manualmente (il tuo trucco Payload->zip)
    app_path = "#{archive_path}/Products/Applications/#{PROJECT_NAME}.app"
    payload_dir = "#{output_dir}/Payload"
    ipa_full_path = "#{output_dir}/#{final_ipa_name}"

    sh "mkdir -p '#{payload_dir}'"
    sh "cp -R '#{app_path}' '#{payload_dir}/'"
    
    Dir.chdir(output_dir) do
      sh "zip -qr '#{final_ipa_name}' Payload"
    end

    # 3. Pulisci i file temporanei
    sh "rm -rf '#{payload_dir}'"
    sh "rm -rf '#{archive_path}'"
    
    UI.success "‚úÖ IPA non firmato creato: #{ipa_full_path}"
    
    next ipa_full_path
  end

end